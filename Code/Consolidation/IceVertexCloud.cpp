///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Contains code for vertex clouds.
 *	\file		IceVertexCloud.cpp
 *	\author		Pierre Terdiman
 *	\date		January, 29, 2000
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Vertex cloud reducer. Use this class to track redundant vertices within a vertex cloud, and delete them.
 *	\class		ReducedVertexCloud
 *	\author		Pierre Terdiman
 *	\version	1.0
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Precompiled Header
#include "Stdafx.h"

using namespace Meshmerizer;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Constructor.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ReducedVertexCloud::ReducedVertexCloud(Point* verts, udword nbverts) : mRVerts(null), mXRef(null), mNbRVerts(0)
{
	mVerts		= verts;
	mNbVerts	= nbverts;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Destructor.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ReducedVertexCloud::~ReducedVertexCloud()
{
	Clean();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	A method to clean the ram used.
 *	\return		Self-reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ReducedVertexCloud& ReducedVertexCloud::Clean()
{
	DELETEARRAY(mXRef);
	DELETEARRAY(mRVerts);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *	Reduction method. Use this to create a minimal vertex cloud.
 *	\param		rc		[out] result structure
 *	\return		true if success
 *	\warning	This is not about welding nearby vertices, here we look for real redundant ones.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ReducedVertexCloud::Reduce(REDUCEDCLOUD* rc)
{
	Clean();

	// 1) Get some ram
	mXRef = new udword[mNbVerts];		CHECKALLOC(mXRef);

	// 2) Initialize a three-keys radix
	float*	x = new float[mNbVerts];	CHECKALLOC(x);
	float*	y = new float[mNbVerts];	CHECKALLOC(y);
	float*	z = new float[mNbVerts];	CHECKALLOC(z);

	// 3) Fill buffers
	for(udword i=0;i<mNbVerts;i++)
	{
		x[i] = mVerts[i].x;
		y[i] = mVerts[i].y;
		z[i] = mVerts[i].z;
	}
	// 4) Perform sort
	RadixSort Radix;
	udword* Sorted = Radix.Sort(x, mNbVerts).Sort(y, mNbVerts).Sort(z, mNbVerts).GetIndices();

	DELETEARRAY(z);
	DELETEARRAY(y);
	DELETEARRAY(x);

	// 5) Loop through all vertices
	// - clean vertex-list by removing redundant vertices
	// - create CrossRef list
	udword NbVertices = 0;
	udword PreviousX = INVALID_ID;
	udword PreviousY = INVALID_ID;
	udword PreviousZ = INVALID_ID;
	Container NewVertices;
	for(i=0;i<mNbVerts;i++)
	{
		udword Vertex	= Sorted[i];				// Vertex number
		udword SortedX	= IR(mVerts[Vertex].x);
		udword SortedY	= IR(mVerts[Vertex].y);
		udword SortedZ	= IR(mVerts[Vertex].z);

		if(SortedX!=PreviousX || SortedY!=PreviousY || SortedZ!=PreviousZ)
		{
			NewVertices.Add(SortedX);
			NewVertices.Add(SortedY);
			NewVertices.Add(SortedZ);
			NbVertices++;
		}
		PreviousX = SortedX;
		PreviousY = SortedY;
		PreviousZ = SortedZ;

		mXRef[Vertex] = NbVertices-1;
	}
	// Here, NbVertices==#non redundant vertices
	mNbRVerts = NbVertices;
	mRVerts = new Point[mNbRVerts];	CHECKALLOC(mRVerts);
	// 6) Create real vertex-list.
	CopyMemory(mRVerts, NewVertices.GetEntries(), NbVertices*sizeof(Point));

	// 7) Fill result structure
	if(rc)
	{
		rc->CrossRef	= mXRef;
		rc->NbRVerts	= mNbRVerts;
		rc->RVerts		= mRVerts;
	}
	return true;
}
